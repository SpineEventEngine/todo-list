# TodoList Example walkthrough

This is the guide of how to get started developing a system 

**Syllabus**:
 - Setting up. Gradle configurations and modules
 - Getting started. Defining the model
 - Writing entity types
 - Repositories and routing set up
 - Configuring deployment
 - Creating a client. Security with gRPC

## Setting up

### Gradle configurations

TodoList uses [Gradle](https://gradle.org/) as the build system.

To set up a Spine application with Gradle, apply the `io.spine.tools.spine-model-compiler` plugin 
and use the required Spine framework dependencies.

It is also required to apply the [Protobuf Gradle plugin](https://github.com/google/protobuf-gradle-plugin)
to the modules which contain Protobuf definitions.

The Spine plugin performs essential configuration of the Protobuf plugin.
The Protobuf files should be placed under `<projectDir>/src/<scope>/proto`, alongside with 
the `java` and `resources` directories.

See the [doc](https://github.com/SpineEventEngine/core-java#gradle-project-dependencies) for 
the entire min Gradle build script.

### Modules

It is recommended to have a separate modules for the model definitions (per bounded context), 
business logic (i.e. entities and repositories) and deployment strategies.

In TodoList there is only one bounded contexts, so all the model is placed under the `model` 
module. The entities and the environment around them is placed in the `api-java` module and 
the deployment configs are placed in the separate modules under the `deployment` dir (with 
the common) parts in `server` module.
The TodoList clients common parts are placed under `client` module, and the clients themselves (CLI 
and Android client) are placed in separate `client-<name>` modules.

## Getting started. Defining the model

As a rule of thumb, any domain-driven development starts with the model.

With Spine, one needs to create Protobuf definitions of the model. For this purpose, TodoList uses
`model` module. The module contains all the required types for entity states, commands, events, 
command rejections, identifiers, etc.

The aggregate and procman types are defined in the `todolist/model.proto` file and the projection 
types are defined in the `todolist/q/projections.proto`, since they only belong to the query side.

Commands, events and rejections belong to the command side. Thus they are defined in `todolist/c/`
package.

Note that the entity identifier types are defined in a separate file `todolist/identifiers.proto`. 
This helps us not to import more than we use when referencing entity types.

### Validation

When looking through the model definitions, one may find a lot of usages of custom field and message
options from `srine/optios.proto`. Most of those options define the validation rules for 
the generated types.

For example, the proto definition of `TaskLabel` looks like:

```proto
message TaskLabel {

    // Label identifier.
    LabelId id = 1;

    // Label title.
    //
    // Cannot be empty.
    string title = 2 [(required) = true];

    // Label color.
    //
    // Optional. Defaults to the `LabelColor.LC_UNDEFINED`.
    LabelColor color = 3;
}
```

Note that the non-empty field `title` is marked as `required`. This allows the framework to validate 
the entity state. For example, if after an event is handled by the `TaskLabel` aggregate the `title`
field holds an empty string, a validation error happens.

To use this feature for non-entity types, use validating builders, generated by the Spine Gradle 
plugin.

For example, here is the definition of `LabelDetails` DTO type:
```proto
message LabelDetails {

    // Label title.
    string title = 1 [(required) = true];

    // Label color.
    LabelColor color = 2;
}
```

Again, `title` is a required field, so the following Java code throws a `ValidationException`:
```java
LabelDetails.newBuilder()
            .setTitle(""); // Error - `title` cannot be an empty string
```

## Writing entity types

Now, when the model is defined with the Protobuf, we are ready to move to the busyness logic coding.

For that, we create Java classes for all the entity types.

Aggregate classes extend `Aggregate` type.

```java
public class LabelAggregate extends Aggregate</* aggregate ID type */    LabelId,           
                                              /* aggregate state type */ TaskLabel, 
                                              /* state VBuilder type */  TaskLabelVBuilder> {
    
}
```

Projection classes extend `Projection` type.

```java
public class MyListViewProjection extends Projection</* projection ID type */    TaskListId, 
                                                     /* projection state type */ MyListView, 
                                                     /* state VBuilder type */   MyListViewVBuilder> {
}
``` 

Procman classes extend `ProcessManager` type.

```java
public class TaskCreationWizard extends ProcessManager</* procman ID type */     TaskCreationId,
                                                       /* procman state type */  TaskCreation,
                                                       /* state VBuilder type */ TaskCreationVBuilder> {
}
```

After declaring the types, we add the command handler methods.

```java
public class LabelAggregate extends Aggregate<LabelId, TaskLabel, TaskLabelVBuilder> {
    
    @Assign
    List<? extends Message> handle(CreateBasicLabel cmd) {
        // Handle the command and produce event(-s).
        //
        // Here the command is validated upon the entity state.
        // It is illegal for aggregates to change their state in the command handler methods (but 
        // it's OK for procmans). 
        // Projections do not handle commands at all.
    }
}
```

Aggregates validate the command upon their state and produce events as the result of the command 
handling. In case of `LabelAggregate`, the `CreateBasicLabel` command handler produces 
`LabelCreated` event.

Command handlers may also throw any `Throwable`s. If a `ThrowableMessage` is thrown from a command
handler method, the command rejection is extracted from it and the command is marked as _rejected_.

## Repositories and routing set up

Each entity type has its own repository type.
The repositories store the data in the provided storage. 

To declare a repository, create a class derived from `AggregateRepository`, `ProjectionRepository` 
or `ProcessManagerRepository`.

In most cases, this is it - nothing else is required from the developer. But in some cases, 
the repositories must perform some custom action. For example, if the message routing should be 
overridden. In this case, the repository may change the outing strategy on creation:

```java
public class MyListViewRepository
        extends ProjectionRepository<TaskListId, MyListViewProjection, MyListView> {

    public MyListViewRepository() {
        super();
        getEventRouting().replaceDefault(((message, context) -> singleton(MyListViewProjection.ID)));
    }
}
```

In the example above the `MyListViewRepository` routes all the messages to a single instance of 
`MyListViewProjection` (making the projection a singleton).

## Configuring deployment

bla blu bla

## Creating a client. Security with gRPC

bla
