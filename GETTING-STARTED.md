# TodoList Example walkthrough

This guide describes the implementation details of TodoList application.

The purpose of this guide is to describe the process of building a Spine-based system with 
the example of TodoList. 
This guide _does not_ cover the process of understanding and structuring 
the [domain model](https://spine.io/docs/guides/model-definition.html). 

For a more general guide, please visit our [docs page](https://spine.io/docs/guides/).

The **target audience** of this guide are developers who are about to start creating an application 
based on Spine. Those developers are generally familiar with both
[DDD](https://martinfowler.com/tags/domain%20driven%20design.html) and Spine 
[core concepts](https://spine.io/docs/guides/introduction.html).

**Syllabus**:
 - [Setting up](#setting-up)
 - [Getting started. Defining the model](#getting-started-defining-the-model)
 - [Writing entity types](#writing-entity-types)
 - [Repositories and routing set up](#repositories-and-routing-set-up)
 - [Configuring deployment](#configuring-deployment)
 - [Creating a client](#creating-a-client)

## Setting up

### Gradle configurations

TodoList uses [Gradle](https://gradle.org/) as the build system.

To set up a Spine application with Gradle, apply the `io.spine.tools.spine-model-compiler` plugin 
and use the required Spine framework dependencies.

It is also required to apply the [Protobuf Gradle plugin](https://github.com/google/protobuf-gradle-plugin)
to the modules which contain Protobuf definitions.

The Spine plugin performs essential configuration of the Protobuf plugin.
The Protobuf files should be placed under `<projectDir>/src/<scope>/proto` directory which goes 
alongside with the `java` and `resources` directories.

See [this doc](https://github.com/SpineEventEngine/core-java#gradle-project-dependencies) for 
the entire min Gradle build script.

### Modules

It is recommended to have separate modules for the model definitions (per bounded context), 
business logic (i.e. entities and repositories) and deployment strategies.

There is only one bounded context in TodoList, so all the model is placed under the `model` 
module. The entities and the environment around them are placed in the `api-java` module and 
the deployment configs are placed in separate modules under the `deployment` dir (with the common
parts in `server` module).
The TodoList clients' common parts are placed under `client` module, and the clients themselves (CLI 
and Android client) are placed in separate `client-<name>` modules.

## Getting started. Defining the model

As a rule of thumb, any domain-driven development starts with the model.

Spine uses [Protobuf](https://developers.google.com/protocol-buffers/) as the model definition 
language. TodoList stores all the model definitions in the `model` module. The module contains all 
the required types for entity states, commands, events, command rejections, identifiers, etc.

The aggregate and procman types are defined in the `todolist/model.proto` file and the projection 
types are defined in the `todolist/q/projections.proto`, since they only belong to the query side.

Commands, events, and rejections belong to the command side. Thus they are defined in `todolist/c/`
package.

Note that the entity identifier types are defined in a separate file `todolist/identifiers.proto`. 
This helps us not to import more than we use when referencing entity types.

### Validation

When looking through the model definitions, one may find a lot of usages of custom field and message
options from `spine/options.proto`. Most of those options define the validation rules for 
the generated types.

For example, the proto definition of `TaskLabel` looks like:

```proto
message TaskLabel {

    // Label identifier.
    LabelId id = 1;

    // Label title.
    //
    // Cannot be empty.
    string title = 2 [(required) = true];

    // Label color.
    //
    // Optional. Defaults to the `LabelColor.LC_UNDEFINED`.
    LabelColor color = 3;
}
```

Note that the non-empty field `title` is marked as `required`. This allows the framework to validate 
the entity state.
For example, the `title` field is checked not to contain an empty string after an event is handled 
by the `TaskLabel` aggregate. If the validation fails, a `io.spine.validate.ValidationException`
is thrown.

To use this feature for non-entity types, use validating builders, generated by the Spine Gradle 
plugin.

For example, here is the definition of `LabelDetails` DTO type:
```proto
message LabelDetails {

    // Label title.
    string title = 1 [(required) = true];

    // Label color.
    LabelColor color = 2;
}
```

Again, `title` is a required field, so the following Java code throws a `ValidationException`:
```java
LabelDetailsVBuilder.newBuilder()
                    .setTitle(""); // Error - `title` cannot be an empty string
```

## Writing entity types

Now, when the model is defined with the Protobuf, we are ready to move to the business logic coding.

For that, we create Java classes for all the entity types.

Aggregate classes extend `Aggregate` type.

```java
public class LabelAggregate extends Aggregate</* aggregate ID type */    LabelId,           
                                              /* aggregate state type */ TaskLabel, 
                                              /* state VBuilder type */  TaskLabelVBuilder> {
}
```

Projection classes extend `Projection` type.

```java
public class MyListViewProjection extends Projection</* projection ID type */    TaskListId, 
                                                     /* projection state type */ MyListView, 
                                                     /* state VBuilder type */   MyListViewVBuilder> {
}
``` 

Procman classes extend `ProcessManager` type.

```java
public class TaskCreationWizard extends ProcessManager</* procman ID type */     TaskCreationId,
                                                       /* procman state type */  TaskCreation,
                                                       /* state VBuilder type */ TaskCreationVBuilder> {
}
```

After declaring the types, we add the command handler methods.

```java
public class LabelAggregate extends Aggregate<LabelId, TaskLabel, TaskLabelVBuilder> {
    
    @Assign
    List<? extends Message> handle(CreateBasicLabel cmd) {
        // Handle the command and produce event(-s).
        //
        // Here the command is validated upon the entity state.
        // It is illegal for aggregates to change their state in the command handler methods (but 
        // it's OK for procmans). 
        // Projections do not handle commands at all.
    }
}
```

An aggregates validates the command upon own state and produces events as the result of the command 
handling. In case of `LabelAggregate`, the `CreateBasicLabel` command handler produces 
`LabelCreated` event.

Command handlers may also throw any `Throwable`s. If a `ThrowableMessage` is thrown from a command
handler method, the command rejection is extracted from it and the command is marked as _rejected_.

Now we declare the event and (optionally) rejection handler methods.

```java
public class LabelAggregate extends Aggregate<LabelId, TaskLabel, TaskLabelVBuilder> {
    
    // ...
    
    @Apply // @Subscribe for non-aggregate event subscribers
    private void labelCreated(LabelCreated event) {
        // Handle the domain events.
        //
        // The entity state can be updated here via `getBuilder()` method.
        // Also, there are helper methods for the lifecycle attributes - `setArchived(boolean)` and 
        // `setDeleted(boolean)`.
    }
}
```

Note that an aggregate type _must_ handle all the events it produces.

## Repositories and routing set up

Each entity type has its own repository type.
The repositories store the data in the provided storage. 

To declare a repository, create a class derived from `AggregateRepository`, `ProjectionRepository` 
or `ProcessManagerRepository`.

In most cases, this is it - nothing else is required from the developer. But in some cases, 
the repositories must perform some custom action. For example, if the message routing should be 
overridden. In this case, the repository may change the routing strategy on creation:

```java
public class MyListViewRepository
        extends ProjectionRepository<TaskListId, MyListViewProjection, MyListView> {

    public MyListViewRepository() {
        super();
        getEventRouting().replaceDefault(((message, context) -> singleton(MyListViewProjection.ID)));
    }
}
```

In the example above the `MyListViewRepository` routes all the events to a single instance of 
`MyListViewProjection` (making the projection a singleton).

## Configuring deployment

Deploying a Spine application implies deploying a number of [gRPC](https://grpc.io/) services 
defined by Spine. 
But first, we must create the bounded context(-s), which is (are) responsible for bringing together 
the service and the entity layers.

To do that, we create an instance of `BoundedContext` and register all the repositories in it (see
`io.spine.examples.todolist.context.BoundedContexts`).
```java
final BoundedContext todoListBc = BoundedContext.newBuilder()
                                                .setStorageFactorySupplier(() -> storageFactory) // *
                                                .setName("TodoListBoundedContext")
                                                .build();
todoListBc.register(new LabelAggregateRepository());
todoListBc.register(new MyListViewRepository());
// ...
```

Note that the `BoundedContext` requires a `StorageFacotry` supplier (`*`). This argument is 
responsible for the type of storage used by the repositories of this bounded context.

Spine provides in-memory (recommended for use in tests), JDBC and Google Cloud Datastore storages
and a well-structured SPI for custom implementations (see `io.spine.server.storage.StorageFactory`).

After all the repositories are registered, the gRPC services can be initialized:
```java
final CommandService commandService = QueryService.newBuilder()
                                                  .add(boundedContext)
                                                  .build();
final QueryService queryService = CommandService.newBuilder()
                                                .add(boundedContext)
                                                .build();
final SubscriptionService commandService = SubscriptionService.newBuilder()
                                                              .add(boundedContext)
                                                              .build();
```

These services should be started on the required server port.
It is not required to start all the services in a single JVM/machine/at all. For example, if 
the application does not use subscriptions, the `SubscriptionService` should not be deployed.

Use `io.spine.server.transport.GrpcContainer` for easier deployment or `io.grpc.Server` for advanced
configuration (see `io.spine.examples.todolist.server.Server` for the example).

## Creating a client

To connect to the server as a client (frontend instance, mobile client, web client, etc.), use 
the [gRPC stubs](https://grpc.io/docs/tutorials/basic/java.html#creating-the-client) API.

It is recommended to create a wrapper for the stubs to avoid misuse. For example, the `TodoClient`,
which is essentially a wrapper for those service stubs, provides API for posting a command to 
the system and fetching the data.

### Security

Note that gRPC expects a security mechanism by default.
See the [doc](https://github.com/grpc/grpc-java/blob/master/SECURITY.md) for more details on 
the security settings for gRPC in Java.
