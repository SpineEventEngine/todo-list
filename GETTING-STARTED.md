# TodoList Example walkthrough

This is the guide of how to get started developing a system 

**Syllabus**:
 - Setting up. Gradle configurations and modules
 - Getting started. Defining the model
 - Writing entity types
 - Repositories and routing set up
 - Configuring deployment
 - Creating a client. Security with gRPC

## Setting up. Gradle configurations and modules

TodoList uses [Gradle](https://gradle.org/) as the build system.

// bla bla 

## Getting started. Defining the model

As a rule of thumb, any domain-driven development starts with the model.

With Spine, one needs to create Protobuf definitions of the model. For this purpose, TodoList uses
`model` module. The module contains all the required types for entity states, commands, events, 
command rejections, identifiers, etc.

The aggregate and procman types are defined in the `todolist/model.proto` file and the projection 
types are defined in the `todolist/q/projections.proto`, since they only belong to the query side.

Commands, events and rejections belong to the command side. Thus they are defined in `todolist/c/`
package.

Note that the entity identifier types are defined in a separate file `todolist/identifiers.proto`. 
This helps us not to import more than we use when referencing entity types.

### Validation

When looking through the model definitions, one may find a lot of usages of custom field and message
options from `srine/optios.proto`. Most of those options define the validation rules for 
the generated types.

For example, the proto definition of `TaskLabel` looks like:

```proto
message TaskLabel {

    // Label identifier.
    LabelId id = 1;

    // Label title.
    //
    // Cannot be empty.
    string title = 2 [(required) = true];

    // Label color.
    //
    // Optional. Defaults to the `LabelColor.LC_UNDEFINED`.
    LabelColor color = 3;
}
```

Note that the non-empty field `title` is marked as `required`. This allows the framework to validate 
the entity state. For example, if after an event is handled by the `TaskLabel` aggregate the `title`
field holds an empty string, a validation error happens.

To use this feature for non-entity types, use validating builders, generated by the Spine Gradle 
plugin.

For example, here is the definition of `LabelDetails` DTO type:
```proto
message LabelDetails {

    // Label title.
    string title = 1 [(required) = true];

    // Label color.
    LabelColor color = 2;
}
```

Again, `title` is a required field, so the following Java code throws a `ValidationException`:
```java
LabelDetails.newBuilder()
            .setTitle(""); // Error - `title` cannot be an empty string
```

## Writing entity types

Now, when the model is defined with the Protobuf, we are ready to move to the busyness logic coding.

For that, we create Java classes for all the entity types.

Aggregate classes extend `Aggregate` type.

```java
public class LabelAggregate extends Aggregate</* aggregate ID type */    LabelId,           
                                              /* aggregate state type */ TaskLabel, 
                                              /* state VBuilder type */  TaskLabelVBuilder> {
    
}
```

Projection classes extend `Projection` type.

```java
public class MyListViewProjection extends Projection</* projection ID type */    TaskListId, 
                                                     /* projection state type */ MyListView, 
                                                     /* state VBuilder type */   MyListViewVBuilder> {
}
``` 

Procman classes extend `ProcessManager` type.

```java
public class TaskCreationWizard extends ProcessManager</* procman ID type */     TaskCreationId,
                                                       /* procman state type */  TaskCreation,
                                                       /* state VBuilder type */ TaskCreationVBuilder> {
}
```

After declaring the types, we add the command handler methods.

```java
public class LabelAggregate extends Aggregate<LabelId, TaskLabel, TaskLabelVBuilder> {
    
    @Assign
    List<? extends Message> handle(CreateBasicLabel cmd) {
        // Handle command and produce event(-s).
        // Here the command is validated upon the entity state.
        // It is illegal for aggregates to change their state in the command handler methods (but 
        // it's OK for procmans). 
        // Projections do not handle commands at all.
    }
}
```

Aggregates validate the command upon their state and produce events as the result of the command 
handling. In case of `LabelAggregate`, the `CreateBasicLabel` command handler produces 
`LabelCreated` event.

Command handlers may also throw any `Throwable`s. If a `ThrowableMessage` is thrown from a command
handler method, the command rejection is extracted from it and the command is marked as _rejected_.

## Repositories and routing set up

bli blo bla

## Configuring deployment

bla blu bla

## Creating a client. Security with gRPC

bla
