/*
 * Copyright 2017, TeamDev Ltd. All rights reserved.
 *
 * Redistribution and use in source and/or binary forms, with or without
 * modification, must retain the above copyright notice and the following
 * disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.spine.examples.todolist.server;

import com.google.common.base.Optional;
import io.spine.core.EventClass;
import io.spine.examples.todolist.context.BoundedContexts;
import io.spine.examples.todolist.q.projection.DraftTasksView;
import io.spine.examples.todolist.q.projection.LabelledTasksView;
import io.spine.examples.todolist.q.projection.MyListView;
import io.spine.server.BoundedContext;
import io.spine.server.catchup.KafkaCatchUp;
import io.spine.server.event.EventBus;
import io.spine.server.event.EventDispatcher;
import io.spine.server.projection.ProjectionRepository;
import io.spine.server.storage.StorageFactory;
import io.spine.server.storage.kafka.KafkaStorageFactory;
import io.spine.server.storage.kafka.KafkaWrapper;

import java.time.Duration;
import java.util.Collection;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Stream;

import static io.spine.server.storage.kafka.Consistency.STRONG;
import static java.time.temporal.ChronoUnit.MILLIS;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;

/**
 * A factory of {@link BoundedContext} instances.
 *
 * <p>The Bounded Contexts generated by this factory use
 * {@linkplain KafkaStorageFactory Kafka-based storage} and
 * {@linkplain KafkaCatchUp Kafka-based read side catch up}.
 *
 * @author Dmytro Dashenkov
 */
final class KafkaBoundedContexts {

    private static final String KAFKA_PRODUCER_PROPS_PATH = "config/kafka-producer.properties";
    private static final String KAFKA_CONSUMER_PROPS_PATH = "config/kafka-consumer.properties";
    private static final String KAFKA_STREAMS_PROPS_PATH = "config/kafka-streams.properties";
    private static final Duration POLL_AWAIT = Duration.of(50, MILLIS);
    private static final StorageFactory storageFactory;

    static {
        final Properties producerConfig = ConfigFiles.loadConfig(KAFKA_PRODUCER_PROPS_PATH);
        final Properties consumerConfig = ConfigFiles.loadConfig(KAFKA_CONSUMER_PROPS_PATH);
        storageFactory = KafkaStorageFactory.newBuilder()
                                            .setProducerConfig(producerConfig)
                                            .setConsumerConfig(consumerConfig)
                                            .setMaxPollAwait(POLL_AWAIT)
                                            .setConsistencyLevel(STRONG)
                                            .build();
    }

    private KafkaBoundedContexts() {
        // Prevent utility class instantiation.
    }

    /**
     * Creates a new instance of the {@link BoundedContext} based with {@link KafkaStorageFactory}
     * and using {@link KafkaCatchUp}.
     *
     * @return the bounded context created with the storage factory
     */
    @SuppressWarnings({
            "Guava", // Spine Java 7 API.
            "ConstantConditions" // Checked within the stream via filter(...).
    })
    static BoundedContext create() {
        final BoundedContext boundedContext = BoundedContexts.create(storageFactory);
        final Collection<ProjectionRepository<?, ?, ?>> projectionRepos =
                Stream.of(MyListView.class, LabelledTasksView.class, DraftTasksView.class)
                      .map(boundedContext::findRepository)
                      .filter(Optional::isPresent)
                      .map(repositoryOptional ->
                                   (ProjectionRepository<?, ?, ?>) repositoryOptional.get())
                      .collect(toList());
        setupDispatchers(boundedContext.getEventBus(), projectionRepos);
        startCatchUp(projectionRepos);
        return boundedContext;
    }

    private static void
    setupDispatchers(EventBus eventBus, Collection<? extends EventDispatcher<?>> typeSuppliers) {
        final Set<EventClass> eventClasses =
                typeSuppliers.stream()
                             .peek(eventBus::unregister)
                             .flatMap(dispatcher -> dispatcher.getMessageClasses().stream())
                             .distinct()
                             .collect(toSet());
        final KafkaWrapper kafkaWrapper = KafkaWrapper.create(
                ConfigFiles.loadConfig(KAFKA_PRODUCER_PROPS_PATH),
                ConfigFiles.loadConfig(KAFKA_CONSUMER_PROPS_PATH));
        final EventDispatcher<?> dispatcher = KafkaCatchUp.dispatcher(eventClasses, kafkaWrapper);
        eventBus.register(dispatcher);
    }

    private static void startCatchUp(Collection<ProjectionRepository<?, ?, ?>> repos) {
        final Properties config = ConfigFiles.loadConfig(KAFKA_STREAMS_PROPS_PATH);
        for (ProjectionRepository<?, ?, ?> repo : repos) {
            KafkaCatchUp.start(repo, config);
        }
    }
}
